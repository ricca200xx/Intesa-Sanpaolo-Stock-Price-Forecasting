final_plot_data <- rbind(df_history_plot, df_future_plot)
# Palette colori
col_hist <- "black"
col_fcst <- "blue"
col_ribbon <- rgb(0, 0, 1, 0.2) # Blu trasparente
# Plot
plot(final_plot_data$Date, final_plot_data$Forecast, type="n",
main=paste("Intesa Sanpaolo: Final Hybrid Forecast (Next", days_ahead, "Days)"),
xlab="Date", ylab="Price (€)",
ylim=c(min(final_plot_data$Forecast, na.rm=T)*0.98, max(final_plot_data$Upper_95, na.rm=T)*1.02))
# 1. Disegna l'area di confidenza (IC 95%)
# (Solo per la parte futura dove Lower/Upper non sono NA)
idx_future <- which(final_plot_data$Type == "Forecast")
polygon(c(final_plot_data$Date[idx_future], rev(final_plot_data$Date[idx_future])),
c(final_plot_data$Lower_95[idx_future], rev(final_plot_data$Upper_95[idx_future])),
col = col_ribbon, border = NA)
# 2. Linea Storica
idx_hist <- which(final_plot_data$Type == "History")
lines(final_plot_data$Date[idx_hist], final_plot_data$Forecast[idx_hist],
col=col_hist, lwd=2)
# 3. Linea Previsione
lines(final_plot_data$Date[idx_future], final_plot_data$Forecast[idx_future],
col=col_fcst, lwd=3)
# 4. Aggiungi Ultimo Prezzo Reale e Prezzo Finale Previsto
last_real <- tail(df_history_plot$Forecast, 1)
last_date <- tail(df_history_plot$Date, 1)
points(last_date, last_real, pch=19, col="black")
text(last_date, last_real, labels=round(last_real, 3), pos=3, cex=0.8)
final_pred <- tail(df_future_plot$Forecast, 1)
final_date <- tail(df_future_plot$Date, 1)
points(final_date, final_pred, pch=19, col="blue")
text(final_date, final_pred, labels=round(final_pred, 3), pos=4, cex=0.8, col="blue")
grid()
legend("topleft", legend=c("Historical Data", "Hybrid Forecast", "95% Confidence Interval"),
col=c("black", "blue", col_ribbon), lty=c(1,1,1), lwd=c(2,3,10), bty="n")
# 1. Preparazione Dati Completi (Tutto lo storico disponibile)
df_full <- data.frame(ds = index(all_price), y = as.numeric(all_price))
# 2. Fit Prophet su TUTTI i dati (Configurazione selezionata da te)
m_final <- prophet(df_full,
daily.seasonality = FALSE,
yearly.seasonality = FALSE,
weekly.seasonality = TRUE)
# 3. Calcolo dei Residui su tutto lo storico
# Serve per addestrare l'ARIMA a correggere gli errori del Prophet
forecast_in_sample <- predict(m_final, df_full)
residuals_full <- df_full$y - forecast_in_sample$yhat
# 4. Fit ARIMA sui Residui Completi
fit_resid_final <- auto.arima(residuals_full)
cat("\n--- Modello Ibrido Refittato su tutto lo storico (Prophet + ARIMA) ---\n")
print(summary(fit_resid_final))
# 5. PREVISIONE FUTURA (30 GIORNI)
days_ahead <- 30
# A) Previsione Prophet (Componente Base)
future_dates <- make_future_dataframe(m_final, periods = days_ahead, freq = "day")
forecast_prophet_full <- predict(m_final, future_dates)
prophet_future <- tail(forecast_prophet_full, days_ahead) # Solo i 30 giorni futuri
# B) Previsione ARIMA (Componente Correttiva)
forecast_resid_future <- forecast(fit_resid_final, h = days_ahead, level = 95)
# 6. CALCOLO PREVISIONE IBRIDA E INTERVALLO DI CONFIDENZA COMBINATO (95%)
# La media è la somma delle medie
hybrid_mean <- prophet_future$yhat + as.numeric(forecast_resid_future$mean)
# Calcolo Incertezza Combinata (Sigma Totale)
# Ricaviamo la deviazione standard dai due intervalli al 95% (z approx 1.96)
sigma_prophet <- (prophet_future$yhat_upper - prophet_future$yhat_lower) / (2 * 1.96)
sigma_arima <- (forecast_resid_future$upper[,1] - forecast_resid_future$lower[,1]) / (2 * 1.96)
# Somma delle varianze (assumendo indipendenza degli errori di stima)
sigma_total <- sqrt(sigma_prophet^2 + sigma_arima^2)
# Costruzione IC Combinato
hybrid_lower <- hybrid_mean - (1.96 * sigma_total)
hybrid_upper <- hybrid_mean + (1.96 * sigma_total)
# 7. Creazione Dataframe per il Plot
df_future_plot <- data.frame(
Date = as.Date(prophet_future$ds),
Forecast = hybrid_mean,
Lower_95 = hybrid_lower,
Upper_95 = hybrid_upper,
Type = "Forecast"
)
# Aggiungiamo gli ultimi 6 mesi di dati reali per contesto visivo
last_6_months <- tail(df_full, 120)
df_history_plot <- data.frame(
Date = as.Date(last_6_months$ds),
Forecast = last_6_months$y,
Lower_95 = NA,
Upper_95 = NA,
Type = "History"
)
final_plot_data <- rbind(df_history_plot, df_future_plot)
# Colori
col_line_hist <- "black"
col_line_fcst <- "blue"
col_ribbon <- rgb(0, 0, 1, 0.2) # Blu trasparente per l'intervallo di confidenza
# Setup del grafico vuoto con i limiti corretti
y_min <- min(final_plot_data$Forecast, final_plot_data$Lower_95, na.rm=TRUE) * 0.98
y_max <- max(final_plot_data$Forecast, final_plot_data$Upper_95, na.rm=TRUE) * 1.02
plot(final_plot_data$Date, final_plot_data$Forecast, type="n",
main=paste("Intesa Sanpaolo: Hybrid Forecast (Next", days_ahead, "Days)"),
xlab="Date", ylab="Price (€)", ylim=c(y_min, y_max))
# 1. Disegna l'area di confidenza (IC 95%) solo per il futuro
idx_future <- which(final_plot_data$Type == "Forecast")
polygon(c(final_plot_data$Date[idx_future], rev(final_plot_data$Date[idx_future])),
c(final_plot_data$Lower_95[idx_future], rev(final_plot_data$Upper_95[idx_future])),
col = col_ribbon, border = NA)
# 2. Linea Storica
idx_hist <- which(final_plot_data$Type == "History")
lines(final_plot_data$Date[idx_hist], final_plot_data$Forecast[idx_hist],
col=col_line_hist, lwd=2)
# 3. Linea Previsione
lines(final_plot_data$Date[idx_future], final_plot_data$Forecast[idx_future],
col=col_line_fcst, lwd=3)
# 4. Etichette ultimo prezzo reale e ultimo previsto
last_real <- tail(df_history_plot$Forecast, 1)
last_date <- tail(df_history_plot$Date, 1)
points(last_date, last_real, pch=19, col="black")
text(last_date, last_real, labels=round(last_real, 3), pos=3, cex=0.8)
final_pred <- tail(df_future_plot$Forecast, 1)
final_date <- tail(df_future_plot$Date, 1)
points(final_date, final_pred, pch=19, col="blue")
text(final_date, final_pred, labels=round(final_pred, 3), pos=4, cex=0.8, col="blue")
# Griglia e Legenda
grid()
legend("topleft", legend=c("Historical Data", "Hybrid Forecast", "95% Confidence Interval"),
col=c("black", "blue", col_ribbon), lty=c(1,1,1), lwd=c(2,3,10), bty="n")
### 1. ENVIRONMENT SETUP
rm(list = ls()) # Clear environment
# Load libraries (auto-install if missing)
libs <- c("quantmod", "fpp2", "zoo", "ggplot2", "forecast", "gam", "prophet", "gridExtra", "urca")
for (lib in libs) {
if (!require(lib, character.only = TRUE)) install.packages(lib)
library(lib, character.only = TRUE)
}
### 2. CUSTOM FUNCTIONS
# Function for manual ARIMA Grid Search
check_arima_aic <- function(data, d = 0, D = 0){
aic_matrix <- matrix(NA, 5, 5)
dimnames(aic_matrix) <- list(AR = 0:4, MA = 0:4)
best_aic <- Inf
best_order <- c(0, 0)
for (p in 0:4) {
for (q in 0:4) {
tryCatch({
fit <- arima(data, order = c(p, d, q),
seasonal = list(order = c(0, D, 0), period = 12), method = "ML")
aic_matrix[p+1, q+1] <- fit$aic
if (fit$aic < best_aic) {
best_aic <- fit$aic
best_order <- c(p, q)
}
}, error = function(e) NULL)
}
}
cat("Best AIC:", best_aic, "\n")
cat("Best Order (p, q):", best_order, "\n")
print(aic_matrix)
}
### 1. ENVIRONMENT SETUP
rm(list = ls()) # Clear environment
# Load libraries (auto-install if missing)
libs <- c("quantmod", "fpp2", "zoo", "ggplot2", "forecast", "gam", "prophet", "gridExtra", "urca")
for (lib in libs) {
if (!require(lib, character.only = TRUE)) install.packages(lib)
library(lib, character.only = TRUE)
}
### 2. CUSTOM FUNCTIONS
# Original function provided for Manual ARIMA Grid Search
arima.aic.manual <- function(mydata, intord = 0, seasord = 0){
aicm <- matrix(0,5,5)
LowestIndex <- 0.0
MAIndex <- 0
ARIndex <- 0
SecondLowestIndex <- 0.0
MAIndexSecond <- 0
ARIndexSecond <- 0
for (i in 0:4) for (j in 0:4) {
fit<-arima(mydata, order = c(i,intord,j),
seasonal = list(order = c(0,seasord,0), period = 12), method = "ML")
aicm[i+1,j+1] <- fit$aic
if (i==0 & j==0) {
LowestIndex <- fit$aic
SecondLowestIndex <- fit$aic
} else if (LowestIndex > aicm[i+1,j+1])  {
LowestIndex <- fit$aic
ARIndex <- i
MAIndex <- j
}else if (SecondLowestIndex > aicm[i+1,j+1]) {
SecondLowestIndex <- fit$aic
ARIndexSecond <- i
MAIndexSecond <- j
}
}
cat("Lowest Index =",LowestIndex, "\n")
cat("AR =",ARIndex, "\n")
cat("MA =",MAIndex, "\n")
rownames(aicm) <- c(0,1,2,3,4)
colnames(aicm) <- c(0,1,2,3,4)
print(aicm)
}
ticker <- "ISP.MI"
end_date <- as.Date("2026-01-01")
start_date <- end_date - (365 * 5)
# Download data
data_raw <- getSymbols(ticker, src = "yahoo", auto.assign = FALSE, from = start_date, to = end_date)
prices <- na.omit(data_raw[, 6]) # Adjusted Price
# Train/Test Split (80/20)
n_total <- length(prices)
split_idx <- floor(0.8 * n_total)
train_vec <- prices[1:split_idx]
test_vec  <- prices[(split_idx + 1):n_total]
test_actual <- as.numeric(test_vec)
# Create Time Series (Frequency: 252 trading days)
train_ts <- ts(as.numeric(train_vec), frequency = 252)
test_ts  <- ts(as.numeric(test_vec), frequency = 252)
# Initial Data Plot
df_plot <- data.frame(
Date = index(prices),
Price = as.numeric(prices),
Set = c(rep("Train", length(train_vec)), rep("Test", length(test_vec)))
)
ggplot(df_plot, aes(x = Date, y = Price, color = Set)) +
geom_line(linewidth = 0.6) +
scale_color_manual(values = c("Train" = "#0072B2", "Test" = "#D55E00")) +
labs(title = paste(ticker, "- Historical Price Data (Train vs Test)"),
subtitle = "5-Year Daily Adjusted Close Prices",
y = "Price (€)", x = "Date") +
theme_minimal() +
theme(legend.position = "bottom")
ggplot(df_plot, aes(x = Date, y = Price, color = Set)) +
geom_line(linewidth = 0.4) +
scale_color_manual(values = c("Train" = "#0072B2", "Test" = "#D55E00")) +
labs(title = paste(ticker, "- Historical Price Data (Train vs Test)"),
subtitle = "5-Year Daily Adjusted Close Prices",
y = "Price (€)", x = "Date") +
theme_minimal() +
theme(legend.position = "bottom")
# Original Series
p1 <- autoplot(Acf(train_ts, plot = FALSE, lag.max = 60)) + ggtitle("ACF - Original Series") + theme_minimal()
p2 <- autoplot(Pacf(train_ts, plot = FALSE, lag.max = 60)) + ggtitle("PACF - Original Series") + theme_minimal()
grid.arrange(p1, p2, nrow = 1)
grid.arrange(p1, p2, ncol = 1)
# Differenced Series
diff_ts <- diff(train_ts)
p3 <- autoplot(Acf(diff_ts, plot = FALSE, lag.max = 60)) + ggtitle("ACF - Differenced Series") + theme_minimal()
p4 <- autoplot(Pacf(diff_ts, plot = FALSE, lag.max = 60)) + ggtitle("PACF - Differenced Series") + theme_minimal()
grid.arrange(p3, p4, ncol = 1)
# Run the manual grid search function (Optional)
arima.aic.manual(train_ts, intord = 1, seasord = 0)
# Selected Model: Random Walk (0,1,0) based on financial series behavior
model_arima <- arima(train_ts, order = c(0, 1, 0), method = "ML")
summary(model_arima)
checkresiduals(model_arima)
# Forecasting
fcst_arima <- forecast(model_arima, h = length(test_ts))
pred_arima <- as.numeric(fcst_arima$mean)
mse_arima <- mean((test_actual - pred_arima)^2)
cat("\nARIMA -> MSE:", mse_arima, "| AIC:", model_arima$aic, "\n")
cat("MSE: ", mse_arima, "AIC:", model_arima$aic, "\n")
# 1. Prophet Setup
df_prophet <- data.frame(ds = index(train_vec), y = as.numeric(train_vec))
model_prophet <- prophet(df_prophet,
daily.seasonality = FALSE,
yearly.seasonality = FALSE,
weekly.seasonality = TRUE)
future_prophet <- make_future_dataframe(model_prophet, periods = length(test_vec), freq = "day")
fcst_prophet_obj <- predict(model_prophet, future_prophet)
# 2. Compute Prophet Residuals
fitted_prophet <- fcst_prophet_obj$yhat[1:nrow(df_prophet)]
resid_prophet <- df_prophet$y - fitted_prophet
# 3. Residual Check (Visual & Test)
par(mfrow=c(2,1))
plot(df_prophet$ds, resid_prophet, type="l", main="Prophet Residuals", ylab="Residual", xlab="Date")
abline(h=0, col="red")
Acf(resid_prophet, main="ACF of Prophet Residuals")
# 3. Residual Check (Visual & Test)
par(mfrow=c(1,2))
plot(df_prophet$ds, resid_prophet, type="l", main="Prophet Residuals", ylab="Residual", xlab="Date")
abline(h=0, col="red")
Acf(resid_prophet, main="ACF of Prophet Residuals")
par(mfrow=c(1,1))
print(Box.test(resid_prophet, lag = 20, type = "Ljung-Box"))
# 4. Model Residuals with ARIMA
model_resid_prophet <- auto.arima(resid_prophet)
cat("\n--- ARIMA Structure on Prophet Residuals ---\n")
summary(model_resid_prophet)
# Final Hybrid Diagnostic
cat("\n--- Final Diagnostic (Hybrid Prophet) ---\n")
checkresiduals(model_resid_prophet)
# 5. Hybrid Forecast (Base + Residuals)
fcst_resid_prophet <- forecast(model_resid_prophet, h = length(test_ts))
# 5. Hybrid Forecast (Base + Residuals)
fcst_resid_prophet <- forecast(model_resid_prophet, h = length(test_ts))
# Base Component (Trend/Seasonality)
pred_base_prophet <- fcst_prophet_obj$yhat[(n_total - length(test_vec) + 1):n_total]
# Corrective Component (Residuals)
pred_corr_prophet <- as.numeric(fcst_resid_prophet$mean)
pred_prophet_hybrid <- pred_base_prophet + pred_corr_prophet
fit_prophet_hybrid <- fitted_prophet + fitted(model_resid_prophet) # For train plot
mse_prophet <- mean((test_actual - pred_prophet_hybrid)^2)
cat("Hybrid Prophet -> MSE:", mse_prophet, "\n")
# 1. Prophet Setup
df_prophet <- data.frame(ds = index(train_vec), y = as.numeric(train_vec))
model_prophet <- prophet(df_prophet,
daily.seasonality = FALSE,
yearly.seasonality = FALSE,
weekly.seasonality = TRUE)
future_prophet <- make_future_dataframe(model_prophet, periods = length(test_vec), freq = "day")
fcst_prophet_obj <- predict(model_prophet, future_prophet)
# 2. Compute Prophet Residuals
fitted_prophet <- fcst_prophet_obj$yhat[1:nrow(df_prophet)]
resid_prophet <- df_prophet$y - fitted_prophet
# 3. Residual Check (Visual & Test)
par(mfrow=c(1,2))
plot(df_prophet$ds, resid_prophet, type="l", main="Prophet Residuals (Raw)", ylab="Residual", xlab="Date")
abline(h=0, col="red")
Acf(resid_prophet, main="ACF of Prophet Residuals")
# 3. Residual Check (Visual & Test)
par(mfrow=c(2,1))
plot(df_prophet$ds, resid_prophet, type="l", main="Prophet Residuals (Raw)", ylab="Residual", xlab="Date")
abline(h=0, col="red")
Acf(resid_prophet, main="ACF of Prophet Residuals")
par(mfrow=c(1,1))
print(Box.test(resid_prophet, lag = 20, type = "Ljung-Box"))
# 4. Model Residuals with ARIMA
model_resid_prophet <- auto.arima(resid_prophet)
cat("\n--- ARIMA Structure on Prophet Residuals ---\n")
summary(model_resid_prophet)
# Final Hybrid Diagnostic
cat("\n--- Final Diagnostic (Hybrid Prophet) ---\n")
checkresiduals(model_resid_prophet)
# 5. Hybrid Forecast (Base + Residuals)
fcst_resid_prophet <- forecast(model_resid_prophet, h = length(test_ts))
# Base Component (Trend/Seasonality)
pred_base_prophet <- fcst_prophet_obj$yhat[(n_total - length(test_vec) + 1):n_total]
# Corrective Component (Residuals)
pred_corr_prophet <- as.numeric(fcst_resid_prophet$mean)
pred_prophet_hybrid <- pred_base_prophet + pred_corr_prophet
fit_prophet_hybrid <- fitted_prophet + fitted(model_resid_prophet) # For train plot
# 6. Metrics Calculation
mse_prophet <- mean((test_actual - pred_prophet_hybrid)^2)
# L'AIC del sistema ibrido è dato dalla componente stocastica (ARIMA)
aic_prophet_hybrid <- model_resid_prophet$aic
cat("Hybrid Prophet -> MSE:", mse_prophet, "\n")
cat("Hybrid Prophet -> AIC (Residual Component):", aic_prophet_hybrid, "\n")
# Model with forced additive trend (AAN)
model_ets <- ets(train_ts, model = "AAN", damped = FALSE)
fcst_ets <- forecast(model_ets, h = length(test_ts))
pred_ets <- as.numeric(fcst_ets$mean)
fit_ets <- as.numeric(fitted(model_ets))
mse_ets <- mean((test_actual - pred_ets)^2)
cat("\nETS -> MSE:", mse_ets, "| AIC:", model_ets$aic, "\n")
checkresiduals(model_ets)
# 1. Setup GAM
t_idx <- 1:length(train_vec)
df_gam_train <- data.frame(y = as.numeric(train_vec), t = t_idx)
df_gam_test  <- data.frame(t = (length(train_vec) + 1):n_total)
# Select best base model
g1 <- gam(y ~ t, data = df_gam_train)
g2 <- gam(y ~ s(t, df=4), data = df_gam_train)
g3 <- gam(y ~ s(t, df=10), data = df_gam_train)
model_gam <- list(g1, g2, g3)[[which.min(c(AIC(g1), AIC(g2), AIC(g3)))]]
# 2. Residuals and ARIMA Correction
resid_gam <- residuals(model_gam)
par(mfrow=c(1,2))
par(mfrow=c(2,1))
plot(resid_gam, type="l", main="GAM Residuals (Raw)", ylab="Residual", xlab="Time Index")
abline(h=0, col="red")
Acf(resid_gam, main="ACF of GAM Residuals")
par(mfrow=c(1,1))
model_resid_gam <- auto.arima(resid_gam)
cat("\n--- ARIMA Structure on GAM Residuals ---\n")
summary(model_resid_gam)
# Final Diagnostic
cat("\n--- Final Diagnostic (Hybrid GAM) ---\n")
checkresiduals(model_resid_gam)
# 3. Hybrid Forecast
pred_base_gam <- predict(model_gam, newdata = df_gam_test)
fcst_resid_gam <- forecast(model_resid_gam, h = length(test_ts))
pred_gam_hybrid <- as.numeric(pred_base_gam) + as.numeric(fcst_resid_gam$mean)
fit_gam_hybrid <- as.numeric(fitted(model_gam)) + fitted(model_resid_gam)
mse_gam <- mean((test_actual - pred_gam_hybrid)^2)
cat("Hybrid GAM -> MSE:", mse_gam, "\n")
# Summary Table
results_table <- data.frame(
Model = c("ARIMA (0,1,0)", "Hybrid Prophet", "ETS (Trend)", "Hybrid GAM"),
AIC_Resid = round(c(model_arima$aic, model_resid_prophet$aic, model_ets$aic, model_resid_gam$aic), 2),
MSE = round(c(mse_arima, mse_prophet, mse_ets, mse_gam), 5)
)
print("--- Performance Comparison Table ---")
print(results_table)
# Prepare Full Vectors for Plotting
full_arima   <- c(as.numeric(fitted(model_arima)), pred_arima)
full_ets     <- c(fit_ets, pred_ets)
full_prophet <- c(as.numeric(fit_prophet_hybrid), pred_prophet_hybrid)
full_gam     <- c(as.numeric(fit_gam_hybrid), pred_gam_hybrid)
# Trim vectors to ensure alignment
len_target <- length(prices)
full_arima   <- full_arima[1:len_target]
full_ets     <- full_ets[1:len_target]
full_prophet <- full_prophet[1:len_target]
full_gam     <- full_gam[1:len_target]
# Comprehensive Comparison Plot
plot(index(prices), as.numeric(prices), type="l", col="lightgray", lwd=3,
main="Model Comparison: In-Sample Fit & Out-of-Sample Forecast",
ylab="Price (€)", xlab="Date")
lines(index(prices), full_arima, col="red", lwd=1)
lines(index(prices), full_prophet, col="blue", lwd=1)
lines(index(prices), full_ets, col="darkgreen", lwd=1)
lines(index(prices), full_gam, col="purple", lwd=1)
abline(v=index(prices)[split_idx], col="black", lty=2, lwd=1.5)
text(index(prices)[split_idx], min(prices), " Test Set Start", pos=4, cex=0.8)
legend("topleft",
legend=c("Actual Data", "ARIMA", "Hybrid Prophet", "ETS", "Hybrid GAM"),
col=c("lightgray", "red", "blue", "darkgreen", "purple"),
lwd=2, bty="n", cex=0.8)
# Comprehensive Comparison Plot
plot(index(prices), as.numeric(prices), type="l", col="lightgray", lwd=2,
main="Model Comparison: In-Sample Fit & Out-of-Sample Forecast",
ylab="Price (€)", xlab="Date")
lines(index(prices), full_arima, col="red", lwd=1)
lines(index(prices), full_prophet, col="blue", lwd=1)
lines(index(prices), full_ets, col="darkgreen", lwd=1)
lines(index(prices), full_gam, col="purple", lwd=1)
abline(v=index(prices)[split_idx], col="black", lty=2, lwd=1.5)
text(index(prices)[split_idx], min(prices), " Test Set Start", pos=4, cex=0.8)
legend("topleft",
legend=c("Actual Data", "ARIMA", "Hybrid Prophet", "ETS", "Hybrid GAM"),
col=c("lightgray", "red", "blue", "darkgreen", "purple"),
lwd=2, bty="n", cex=0.8)
# Zoom on Test Set
plot(index(test_vec), test_actual, type="l", col="black", lwd=2,
main="Zoom: Test Set Forecasting Accuracy",
ylab="Price (€)", xlab="Date",
ylim=c(min(test_actual)*0.9, max(test_actual)*1.1))
lines(index(test_vec), pred_arima, col="red", lwd=2)
lines(index(test_vec), pred_prophet_hybrid, col="blue", lwd=2)
lines(index(test_vec), pred_ets, col="darkgreen", lwd=2)
lines(index(test_vec), pred_gam_hybrid, col="purple", lwd=2)
legend("bottomleft",
legend=c("Actual", "ARIMA", "Hybrid Prophet", "ETS", "Hybrid GAM"),
col=c("black", "red", "blue", "darkgreen", "purple"),
lwd=2, bty="n", cex=0.8)
# 1. Prepare Full Dataset
df_full <- data.frame(ds = index(prices), y = as.numeric(prices))
# 2. Fit Full Prophet Model
final_prophet <- prophet(df_full,
daily.seasonality = FALSE,
yearly.seasonality = FALSE,
weekly.seasonality = TRUE)
# 3. Fit ARIMA on Full Residuals
in_sample_fcst <- predict(final_prophet, df_full)
full_residuals <- df_full$y - in_sample_fcst$yhat
final_resid_arima <- auto.arima(full_residuals)
cat("\n--- Final Model: Residual ARIMA Structure ---\n")
summary(final_resid_arima)
# 4. Generate Future Forecast (30 days)
days_ahead <- 30
# Component A: Prophet (Trend/Seasonality)
future_dates_final <- make_future_dataframe(final_prophet, periods = days_ahead, freq = "day")
fcst_prophet_final <- predict(final_prophet, future_dates_final)
future_base <- tail(fcst_prophet_final, days_ahead)
# Component B: ARIMA (Error Correction)
fcst_resid_final <- forecast(final_resid_arima, h = days_ahead, level = 95)
# 5. Combine and Calculate Confidence Intervals
final_mean <- future_base$yhat + as.numeric(fcst_resid_final$mean)
# Combine Sigmas for 95% CI
sigma_p <- (future_base$yhat_upper - future_base$yhat_lower) / (2 * 1.96)
sigma_a <- (fcst_resid_final$upper[,1] - fcst_resid_final$lower[,1]) / (2 * 1.96)
sigma_tot <- sqrt(sigma_p^2 + sigma_a^2)
final_lower <- final_mean - (1.96 * sigma_tot)
final_upper <- final_mean + (1.96 * sigma_tot)
# Prepare Plotting Data
df_future <- data.frame(
Date = as.Date(future_base$ds),
Price = final_mean,
Lower = final_lower,
Upper = final_upper,
Type = "Forecast"
)
# Add historical context (last 6 months)
df_history <- data.frame(
Date = as.Date(tail(df_full$ds, 120)),
Price = tail(df_full$y, 120),
Lower = NA, Upper = NA,
Type = "History"
)
plot_data <- rbind(df_history, df_future)
# Final Plot
y_lims <- c(min(plot_data$Price, plot_data$Lower, na.rm=T)*0.98,
max(plot_data$Price, plot_data$Upper, na.rm=T)*1.02)
plot(plot_data$Date, plot_data$Price, type="n", ylim=y_lims,
main=paste("Intesa Sanpaolo: Hybrid Forecast (Next", days_ahead, "Days)"),
xlab="Date", ylab="Price (€)")
# Confidence Interval Area
idx_fut <- which(plot_data$Type == "Forecast")
polygon(c(plot_data$Date[idx_fut], rev(plot_data$Date[idx_fut])),
c(plot_data$Lower[idx_fut], rev(plot_data$Upper[idx_fut])),
col = rgb(0, 0, 1, 0.2), border = NA)
# Lines
idx_hist <- which(plot_data$Type == "History")
lines(plot_data$Date[idx_hist], plot_data$Price[idx_hist], col="black", lwd=2)
lines(plot_data$Date[idx_fut], plot_data$Price[idx_fut], col="blue", lwd=3)
# Points and Labels
last_hist_val <- tail(df_history$Price, 1)
last_hist_date <- tail(df_history$Date, 1)
points(last_hist_date, last_hist_val, pch=19, col="black")
text(last_hist_date, last_hist_val, labels=round(last_hist_val, 3), pos=3, cex=0.8)
last_pred_val <- tail(df_future$Price, 1)
last_pred_date <- tail(df_future$Date, 1)
points(last_pred_date, last_pred_val, pch=19, col="blue")
text(last_pred_date, last_pred_val, labels=round(last_pred_val, 3), pos=4, cex=0.8, col="blue")
grid()
legend("topleft", legend=c("Historical Data", "Hybrid Forecast", "95% Confidence Interval"),
col=c("black", "blue", rgb(0, 0, 1, 0.2)), lty=1, lwd=c(2,3,10), bty="n")
